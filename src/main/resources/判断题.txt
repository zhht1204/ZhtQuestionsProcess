233．不是所有的用户请求都提交给服务器。（对）
234．在Servlet的生命周期中，仅执行一次init方法，是在服务器装入Servlet时执行的。（对）
235．在Struts2 framework中，Controller主要是ActionServlet。（错）
236．javaBean+jsp+servlet不是基于mvc模式。（错）
237．mvc模式使软件开发中的分工更加明确，协同开发，互不影响。（错）
238．XML也是一种基于文本的标记语言。（对）
239．关于XML基本语法元素不区分大小写。（错）
240．关于XML基本语法元素可以嵌套，可以重叠。（对）
241．Spring是一个开源框架，它是为了解决企业应用开发的复杂性而创建的。（对）
242．Spring将使用接口的复杂度降低到零。（对）
243．Spring应用中的对象依赖于Spring的特定类。（错）
244．Spring可以将简单的组件配置、组合成为复杂的应用。（对）
245．HibernateTemplate不可以公用多个DAO。（对）
246．关于在hibernaet中实体关系映射多对多包括单向多对多和双向多对多。（对）
247．事务隔离级别是由数据库系统实现的。（错）
248．session的save()方法把一个临时对象转变为持久话对象。（对）
249．session的load(),get()方法返回的对象总是处于持久化状态。（对）
250．session的save(),find()方法返回的list集合中存放的都是持久话对象。（对）
251．关于struts标签<logic;greaterEqual>如果常数小于等于被定义的实体，返回true。（错）
252．内部类只能声明public访问限制。（错）
253．jsp不采用多线程。（错）
254．Struts是MVC的一种实现，它将Servlet和JSP标记（属于J2EE规范）用作实现的一部分。（对）
255．一个SessionFactory对象对应一个数据库存储源。（对）
256．在java中一个类只能实现一个接口。（错）
257．在java中一个类不能同时继承一个类和实现一个接口。（错）
258．类具有封装性，但可以通过类的公共接口访问类中的数据。（对）
259．声明一个类时，必须用public修饰符。（错）
260．关于集合 List 接口继承了Collection接口以定义一个不允许重复项的有序集合。（错）
261．要支持随机访问，选择LinkedList类较好，而顺序的访问列表元素使用ArrayList类更好。（错）
262．Set 接口继承Collection接口，而且它允许集合中存在重复项。（错）
263．ArrayList对象中不能存放NULL。（错）
264．关于垃圾回收机制，当JVM处于空闲时，垃圾收集器线程会自动检查每一块分配出去的内存空间。（对）/*参考前面的选择题*/
265．NULL是java关键字。（错）
266．关于JAVA序列化与反序列化，任何类的对象都能被序列化。（错）
267．关于JAVA序列化与反序列化，对实现了Serializable接口的类，采用默认的反序列化方式。（错）
268．关于JAVA序列化与反序列化，采用默认的序列化方式。（错）
269．内部类不能访问外部类的所有方法与属性。（错）
270．内部类只能被它的外部类，不能再被其他的类使用。（错）
271．内部类可以将一些非面向对象的语句块对象化。（错）
272．使用内部类，可以使得代码更加灵活和富有扩展性。（错）
273．面向对象的技术已经在现在的软件开发中占据了主流的位置。（对）
274．软件开发过程中的任何一个活动都是为了能够产出优秀的代码。所以，代码才是核心。（对）
275．JDBC由一组用java语言编写的类与接口组成。（对）
276．JDBC可以为多种关系数据库提供统一的访问接口。（对）
277．工厂模式可以根据所提供的数据返回某一子类的实例。（对）
278．工厂模式中，通常分为工厂类和工厂方法。（对）
279．工厂模式中，子类都实现不同的功能。（对）
280．关于DOM 的缺点，不可以修改XML文档。（错）
281．关于DOM 的缺点，解析速度慢。（错）
282．关于DOM 的缺点，把整个文档及其树状结构对应的对象全部保存在内存中。属于内存密集型，不合适处理大型XML文档。（对）
283．关于DOM 的缺点，由于 DOM 可以使用任何语音编写实现，所以方法等命名习惯（Naming Convention）没有遵守标准的Java命名习惯。（对）
284．SAX 解析器将解析文档，并在最后解析完成时报告文档。（错）
285．SAX 解析器将在它捕捉到错误时报告它们。（对）
286．DOM 解析器将基于事件驱动模型报告元素和节点。（错）
287．所有的 HTML 标记都是预定义的，用户不能自定义自己的标记。（对）
288．HTML 主要是用来描述数据的显示格式，而不能描述数据的结构及语义（Semantics）。（错）
289．HTML5 语言语法不够严格。（错）
290．DOM 树提供了非常稳定的API。（对）
291．搜索引擎开发人员几乎不能从 HTML 标记本身得到任何有用的信息。（错）
292．XML 解析处理 API 类型包括DOM、SAX、SOAP。（错）
293．SAX 对大文档非常适合，但是只能读取文档，不能修改。（对）
294．DOM对小文档非常适合。（对）
295．DOM能很容易更改文档内容。（对）
296．SAX事件驱动型，非常节省内存。（对）
297．XSL 包括了XPath、XLink、XSL。（错）
298．DTD是基于正则表达式的，描述能力有限。（对）
299．DTD没有数据类型的支持，在大多数应用环境下能力不足。（对）
300．DTD的约束定义能力不足，无法对XML实例文档作出更细致的语义限制。（对）
301．DTD并非使用XML作为描述手段，而DTD的构建和访问并没有标准的编程接口，无法使用标准的编程方式进行DTD维护。（对）
302．在C/S结构，即客户端/服务器结构中，有专门的数据库服务器，但客户端还要运行客户端应用程序，这也叫做胖客户端。（对）
303．在B/S结构中，客户端在浏览器中只负责表示层逻辑的实现，业务逻辑和数据库都在服务器端运行。也就是说，应用程序部署在服务器端，客户端通过浏览器访问应用程序。（对）
304．通常B/S结构中，客户端发送HTTP请求消息传给服务器，服务器将请求传递给Web应用程序，Web应用程序处理请求，并把相应的HTML页面传给客户端。（对）
305．Web应用是基于C/S结构的，也就是客户端/服务器结构。（错）
306．MVC模式使应用程序的结构更加清晰，通过将代码按照层次划分为业务逻辑/数据层、用户界面和应用流程控制这三个层次，能够增强代码的稳定性。（对）
307．MVC模式实现了很好的分布式组件架构。（错）
308．对于项目开发而言，MVC三层的分离有利于在项目小组内按照小组成员各自的擅长进行分工，有利于三个部分并行开发、加快项目进度。（对）
309．MVC模块功能的划分有利于在代码修改过程中进行模块的隔离，而不需要把具有不同功能的代码混杂在一起造成混乱。（对）
310．HttpServletRequest对象封装客户的请求信息，这些信息包括客户的环境信息和从客户端送到服务器端的数据。（对）
311．HttpServletRequest类包含了从请求对象中抽取信息的一系列方法。（对）
312．HttpServletResponse对象封装了动态产生的响应。例如，一个返回给客户端的HTML页面，这个HTML页面一般是由来自HttpServletResquest对象的数据构成的。（对）
313．一个响应对象只能是HTML页面或者一个Servlet。（错）
314．getCookies方法会返回Cookie头的内容，解析后会存放在Cookie对象的数组中。（对）
315．getHeaderNames方法返回当前请求的所有头的名称的字符串对象。（错）
316．getMethod方法返回请求方法，通常是GET或者POST。（对）
317．getProtocol返回HTTP版本号。（对）
318．getPath和setPath方法获取或设置cookie应用的路径。如果不指定路径，浏览器将只把cookie返回给包含发送此cookie的页面的路径及其子路径。（对）
319．获取cookie的名字用cookie的getName方法，getValue方法获取cookie的值。设置cookie的值用setValue方法。（对）
320．软件开发方法可归纳为三种模式：基于瀑布模型的结构化生命周期法、基于动态需求定义的原型化方法和面向对象的方法。（对）
321．JDBC是ODBC的升级，适合于各种编程语言调用。（错）
322．CallableStatement对象是用Connection方法prepareCall创建的。（对）
323．为定义一个XML文档的结构，开发者可以使用的XML技术有DTD、XML Schema、UML。(错)
324．在XML中，DOM中IXMLDOMNodeList的length属性表示的是该对象中元素节点的数量。（对）
325．Session有open()方法。（错）
326．创建jdbc总共有6大步，最后一步是处理结果集。（错）
327．hibernate和jdbc相比能够处理大量的数据。（错）
